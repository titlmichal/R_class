)
# Čísla položek škál dotazníku IPIP:
# Extraversion: 1 6 11 16 21 26 31 36 41 46
# Agreeableness: 2 7 12 17 22 27 32 37 42 47
# Conscientiousness: 3 8 13 18 23 28 33 38 43 48
# Emotional stability: 4 9 14 19 24 29 34 39 44 49
# Intellect: 5 10 15 20 25 30 35 40 45 50
items
# Vytvořte list items, jehož prvky budou textové vektory s názvy položek
# jednotlivých škál. Samotné vektory by měly být pojmenovány podle zkratek škál
# První dva prvky by vypadaly takto:
items <- list(
nfc = item_range("nfc_", 1:16),
ext = item_range("ipip_", seq(1, 50, by = 5)),
agg = item_range("ipip_", seq(2, 50, by = 5)),
con = item_range("ipip_", seq(3, 50, by = 5)),
emo = item_range("ipip_", seq(4, 50, by = 5)),
int = item_range("ipip_", seq(5, 50, by = 5))
)
# Čísla položek škál dotazníku IPIP:
# Extraversion: 1 6 11 16 21 26 31 36 41 46
# Agreeableness: 2 7 12 17 22 27 32 37 42 47
# Conscientiousness: 3 8 13 18 23 28 33 38 43 48
# Emotional stability: 4 9 14 19 24 29 34 39 44 49
# Intellect: 5 10 15 20 25 30 35 40 45 50
items
# Vypočtěte celkové skóry pro všechny škály
# Můžete k tomu použít následující funkci v kombinaci s listem z předchozího
# kroku.
# Umístěte nově vzniklé sloupce někde na začátek datasetu, třeba za demografické
# proměnné a při použití funkce row_mean() nastavte, ať se vždy tolerují
# dvě nevyplněné položky
row_mean <- function(..., max.na = 0) {
data <- pick(...)
n_miss <- data %>%
is.na() %>%
rowSums()
output <- data %>%
rowMeans(na.rm = TRUE)
output[n_miss > max.na] <- NA_real_
return(output)
}
data
df %>%
mutate(nfc = row_mean(all_of(items$nfc), max.na = 2),
ext = row_mean(all_of(items$ext), max.na = 2),
agg = row_mean(all_of(items$agg), max.na = 2),
con = row_mean(all_of(items$con), max.na = 2),
emo = row_mean(all_of(items$emo), max.na = 2),
int = row_mean(all_of(items$int), max.na = 2),
, .after = class)
df %>%
mutate(
nfc = row_mean(all_of(items$nfc), max.na = 2),
ext = row_mean(all_of(items$ext), max.na = 2),
agg = row_mean(all_of(items$agg), max.na = 2),
con = row_mean(all_of(items$con), max.na = 2),
emo = row_mean(all_of(items$emo), max.na = 2),
int = row_mean(all_of(items$int), max.na = 2),
, .after = class)
data %>%
mutate(
nfc = row_mean(all_of(items$nfc), max.na = 2),
ext = row_mean(all_of(items$ext), max.na = 2),
agg = row_mean(all_of(items$agg), max.na = 2),
con = row_mean(all_of(items$con), max.na = 2),
emo = row_mean(all_of(items$emo), max.na = 2),
int = row_mean(all_of(items$int), max.na = 2),
, .after = class)
data <- data %>%
mutate(
nfc = row_mean(all_of(items$nfc), max.na = 2),
ext = row_mean(all_of(items$ext), max.na = 2),
agg = row_mean(all_of(items$agg), max.na = 2),
con = row_mean(all_of(items$con), max.na = 2),
emo = row_mean(all_of(items$emo), max.na = 2),
int = row_mean(all_of(items$int), max.na = 2),
, .after = class)
data
# Pomocí funkce group_by() rozdělte dataset do skupin podle ročníku a pohlaví
# (alternativně to jde i pomocí arugmentu .by až v rámci funkce summarise())
# a pak vypočtěte deskriptivní statistiky (průměry a směrodatné odchylky)
# pro všechny škály (NFC a dimenze Big Five)
data %>%
group_by(grade, gender)
# Pomocí funkce group_by() rozdělte dataset do skupin podle ročníku a pohlaví
# (alternativně to jde i pomocí arugmentu .by až v rámci funkce summarise())
# a pak vypočtěte deskriptivní statistiky (průměry a směrodatné odchylky)
# pro všechny škály (NFC a dimenze Big Five)
data %>%
group_by(grade, gender) %>%
summarise(M_nfc = mean(nfc, na.rm = TRUE),
SD_nfc = sd(nfc, na.rm = TRUE),
M_ext = mean(ext, na.rm = TRUE),
SD_ext = sd(ext, na.rm = TRUE),
M_agg = mean(agg, na.rm = TRUE),
SD_agg = sd(agg, na.rm = TRUE),
M_con = mean(con, na.rm = TRUE),
SD_con = sd(con, na.rm = TRUE),
M_emo = mean(emo, na.rm = TRUE),
SD_emo = sd(emo, na.rm = TRUE),
M_int = mean(ext, na.rm = TRUE),
SD_int = sd(ext, na.rm = TRUE)
)
# Pomocí funkce group_by() rozdělte dataset do skupin podle ročníku a pohlaví
# (alternativně to jde i pomocí arugmentu .by až v rámci funkce summarise())
# a pak vypočtěte deskriptivní statistiky (průměry a směrodatné odchylky)
# pro všechny škály (NFC a dimenze Big Five)
data %>%
group_by(grade, gender) %>%
summarise(M_nfc = mean(nfc, na.rm = TRUE),
SD_nfc = sd(nfc, na.rm = TRUE),
M_ext = mean(ext, na.rm = TRUE),
SD_ext = sd(ext, na.rm = TRUE),
M_agg = mean(agg, na.rm = TRUE),
SD_agg = sd(agg, na.rm = TRUE),
M_con = mean(con, na.rm = TRUE),
SD_con = sd(con, na.rm = TRUE),
M_emo = mean(emo, na.rm = TRUE),
SD_emo = sd(emo, na.rm = TRUE),
M_int = mean(int, na.rm = TRUE),
SD_int = sd(int, na.rm = TRUE)
)
# Doplňující úkoly (NEPOVINNÉ)
# Zopakujte předchozí krok, ale doplňte i údaje o počtu validních a chybějících
# hodnot
data %>%
group_by(grade, gender) %>%
summarise(M_nfc = mean(nfc, na.rm = TRUE),
SD_nfc = sd(nfc, na.rm = TRUE),
M_ext = mean(ext, na.rm = TRUE),
SD_ext = sd(ext, na.rm = TRUE),
M_agg = mean(agg, na.rm = TRUE),
SD_agg = sd(agg, na.rm = TRUE),
M_con = mean(con, na.rm = TRUE),
SD_con = sd(con, na.rm = TRUE),
M_emo = mean(emo, na.rm = TRUE),
SD_emo = sd(emo, na.rm = TRUE),
M_int = mean(int, na.rm = TRUE),
SD_int = sd(int, na.rm = TRUE),
valid = count(!is.na(nfc))
)
# Doplňující úkoly (NEPOVINNÉ)
# Zopakujte předchozí krok, ale doplňte i údaje o počtu validních a chybějících
# hodnot
data %>%
group_by(grade, gender) %>%
summarise(M_nfc = mean(nfc, na.rm = TRUE),
SD_nfc = sd(nfc, na.rm = TRUE),
M_ext = mean(ext, na.rm = TRUE),
SD_ext = sd(ext, na.rm = TRUE),
M_agg = mean(agg, na.rm = TRUE),
SD_agg = sd(agg, na.rm = TRUE),
M_con = mean(con, na.rm = TRUE),
SD_con = sd(con, na.rm = TRUE),
M_emo = mean(emo, na.rm = TRUE),
SD_emo = sd(emo, na.rm = TRUE),
M_int = mean(int, na.rm = TRUE),
SD_int = sd(int, na.rm = TRUE),
valid = sum(!is.na(nfc))
)
# Doplňující úkoly (NEPOVINNÉ)
# Zopakujte předchozí krok, ale doplňte i údaje o počtu validních a chybějících
# hodnot
data %>%
group_by(grade, gender) %>%
summarise(M_nfc = mean(nfc, na.rm = TRUE),
SD_nfc = sd(nfc, na.rm = TRUE),
M_ext = mean(ext, na.rm = TRUE),
SD_ext = sd(ext, na.rm = TRUE),
M_agg = mean(agg, na.rm = TRUE),
SD_agg = sd(agg, na.rm = TRUE),
M_con = mean(con, na.rm = TRUE),
SD_con = sd(con, na.rm = TRUE),
M_emo = mean(emo, na.rm = TRUE),
SD_emo = sd(emo, na.rm = TRUE),
M_int = mean(int, na.rm = TRUE),
SD_int = sd(int, na.rm = TRUE),
valid_nfc = sum(!is.na(nfc)),
missing_nfc é sum(is.na(nfc))
# Doplňující úkoly (NEPOVINNÉ)
# Zopakujte předchozí krok, ale doplňte i údaje o počtu validních a chybějících
# hodnot
data %>%
group_by(grade, gender) %>%
summarise(M_nfc = mean(nfc, na.rm = TRUE),
SD_nfc = sd(nfc, na.rm = TRUE),
M_ext = mean(ext, na.rm = TRUE),
SD_ext = sd(ext, na.rm = TRUE),
M_agg = mean(agg, na.rm = TRUE),
SD_agg = sd(agg, na.rm = TRUE),
M_con = mean(con, na.rm = TRUE),
SD_con = sd(con, na.rm = TRUE),
M_emo = mean(emo, na.rm = TRUE),
SD_emo = sd(emo, na.rm = TRUE),
M_int = mean(int, na.rm = TRUE),
SD_int = sd(int, na.rm = TRUE),
valid_nfc = sum(!is.na(nfc)),
missing_nfc = sum(is.na(nfc))
)
# Doplňující úkoly (NEPOVINNÉ)
# Zopakujte předchozí krok, ale doplňte i údaje o počtu validních a chybějících
# hodnot
data %>%
group_by(grade, gender) %>%
summarise(M_nfc = mean(nfc, na.rm = TRUE),
SD_nfc = sd(nfc, na.rm = TRUE),
valid_nfc = sum(!is.na(nfc)),
missing_nfc = sum(is.na(nfc)),
M_ext = mean(ext, na.rm = TRUE),
SD_ext = sd(ext, na.rm = TRUE),
valid_ext = sum(!is.na(ext)),
missing_ext = sum(is.na(ext)),
M_agg = mean(agg, na.rm = TRUE),
SD_agg = sd(agg, na.rm = TRUE),
valid_agg = sum(!is.na(agg)),
missing_agg = sum(is.na(agg)),
M_con = mean(con, na.rm = TRUE),
SD_con = sd(con, na.rm = TRUE),
valid_con = sum(!is.na(con)),
missing_con = sum(is.na(con)),
M_emo = mean(emo, na.rm = TRUE),
SD_emo = sd(emo, na.rm = TRUE),
valid_emo = sum(!is.na(emo)),
missing_emo = sum(is.na(emo)),
M_int = mean(int, na.rm = TRUE),
SD_int = sd(int, na.rm = TRUE),
valid_int = sum(!is.na(int)),
missing_int = sum(is.na(int))
)
# Rozdělte dataset opět podle ročníku a pohlaví, ale místo průměrů a SD
# vypočtěte hodnoty kvartilů
data %>%
group_by(grade, gender) %>%
summarise(
as_tibble_row(quantile(nfc))
)
# Rozdělte dataset opět podle ročníku a pohlaví, ale místo průměrů a SD
# vypočtěte hodnoty kvartilů
data %>%
group_by(grade, gender) %>%
summarise(
as_tibble_row(quantile(nfc), na.rm = TRUE)
)
# Rozdělte dataset opět podle ročníku a pohlaví, ale místo průměrů a SD
# vypočtěte hodnoty kvartilů
data %>%
group_by(grade, gender) %>%
summarise(
as_tibble_row(quantile(nfc, na.rm = TRUE))
)
# Rozdělte dataset opět podle ročníku a pohlaví, ale místo průměrů a SD
# vypočtěte hodnoty kvartilů
data %>%
group_by(grade, gender) %>%
summarise(
as_tibble_row(quantile(nfc, na.rm = TRUE)),
as_tibble_row(quantile(ext, na.rm = TRUE))
)
# Rozdělte dataset opět podle ročníku a pohlaví, ale místo průměrů a SD
# vypočtěte hodnoty kvartilů
data %>%
group_by(grade, gender) %>%
summarise(
as_tibble_row(quantile(nfc, na.rm = TRUE))
)
# Rozdělte dataset opět podle ročníku a pohlaví, ale místo průměrů a SD
# vypočtěte hodnoty kvartilů
data %>%
group_by(grade, gender) %>%
summarise(
as_tibble_row(quantile(nfc, na.rm = TRUE)),
as_tibble_row(quantile(ext, na.rm = TRUE))
)
# Rozdělte dataset opět podle ročníku a pohlaví, ale místo průměrů a SD
# vypočtěte hodnoty kvartilů
data %>%
group_by(grade, gender) %>%
summarise(
as_tibble_row(quantile(nfc, na.rm = TRUE),
quantile(ext, na.rm = TRUE))
)
)
# Rozdělte dataset opět podle ročníku a pohlaví, ale místo průměrů a SD
# vypočtěte hodnoty kvartilů
data %>%
group_by(grade, gender) %>%
summarise(
as_tibble_row(quantile(nfc, na.rm = TRUE)
))
data %>%
group_by(grade, gender) %>%
summarise(
across(
c(nfc, ext, agg, con, emo, int),
~ as_tible_row(quantile(.x, probs = c(0.25, 0.5, 0.75), na.rm = TRUE)),
.names = "{.col}_Q{.fn}"
))
data %>%
group_by(grade, gender) %>%
summarise(
across(
c(nfc, ext, agg, con, emo, int),
~ as_tibble_row(quantile(.x, probs = c(0.25, 0.5, 0.75), na.rm = TRUE)),
.names = "{.col}_Q{.fn}"
))
data %>%
group_by(grade, gender) %>%
summarise(
across(
c(nfc, ext, agg, con, emo, int),
~ as_tibble_row(quantile(.x, probs = c(0.25, 0.5, 0.75), na.rm = TRUE)),
.names = "{.col}_Q{.fn}"
))
library(tidyverse)
# 1) Pracujte nejprve s tímto vektorem
# A pokuste se aspoň dvěma různými způsoby vybrat z něj všechny sudé prvky
x <- c(one = 1,
two = 2,
three = 3,
four = 4,
five = 5,
six = 6,
seven = 7,
eight = 8,
nine = 9,
ten = 10)
# 1) Pracujte nejprve s tímto vektorem
# A pokuste se aspoň dvěma různými způsoby vybrat z něj všechny sudé prvky
x <- c(one = 1,
two = 2,
three = 3,
four = 4,
five = 5,
six = 6,
seven = 7,
eight = 8,
nine = 9,
ten = 10)
x
x %>%
select(x // 2 = 0)
x %>%
select(x % 2 = 0)
x[x % 2 == 0]
x[x %% 2 == 0]
x[c(1,2)]
x[c(2,4,6,8,10)]
# 2) Pracujte s tímto dataframem (resp. tibblem)
df <- tibble(
name = c("Mercury", "Venus", "Earth", "Mars",
"Jupiter", "Saturn", "Uranus", "Neptune"),
type = c("Terrestrial", "Terrestrial", "Terrestrial","Terrestrial",
"Gas giant", "Gas giant", "Gas giant", "Gas giant"),
diameter = c(0.382, 0.949, 1, 0.532, 11.209, 9.449, 4.007, 3.883),
rotation = c(58.64, -243.02, 1, 1.03, 0.41, 0.43, -0.72, 0.67),
rings = c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)
)
df
# A podle zadání vyberte příslušné řádky a/nebo sloupce
# Klidně můžete použít funkce balíčku dplyr (který patří pod tidyverse)
# (Dobrovolný, těžší úkol: zkuste to pak pouze s využitím zákldních funkcí
# R, tj. bez použití dplyr funkcí jako select() nebo filter())
# Vyberte všechny informace o Marsu
df %>%
filter(name = "Mars")
# A podle zadání vyberte příslušné řádky a/nebo sloupce
# Klidně můžete použít funkce balíčku dplyr (který patří pod tidyverse)
# (Dobrovolný, těžší úkol: zkuste to pak pouze s využitím zákldních funkcí
# R, tj. bez použití dplyr funkcí jako select() nebo filter())
# Vyberte všechny informace o Marsu
df %>%
filter(name == "Mars")
df
# Vyberte sloupec diameter
df %>%
select(diameter)
# Vyberte planety, které mají prstence
df
# Vyberte planety, které mají prstence
df %>%
filter(type == "Gas giant")
# Vyberte sloupec typu planety, ale jen planety s prstenci
df %>%
filter(type == "Gas giant") %>%
select(type)
# Konvertujte sloupec type na factor tak, aby první úroveň byla
# "Terrestial"
df %>%
mutate(
type = factor(type,
levels = c("Terrestial", "Gas giant"))
)
# Vyberte planety, které mají prstence
df %>%
filter(rings == TRUE)
# Vyberte sloupec typu planety, ale jen planety s prstenci
df %>%
filter(rings == TRUE) %>%
select(type)
# Konvertujte sloupec type na factor tak, aby první úroveň byla
# "Terrestial"
df %>%
mutate(
type = factor(type,
levels = c("Terrestial", "Gas giant"))
)
# Která planeta se otáčí opačně než Země a zároveň nemá prstence?
df %>%
filter(rotation < 0 %AND% rings == FALSE)
# Která planeta se otáčí opačně než Země a zároveň nemá prstence?
df %>%
filter(rotation < 0 & rings == FALSE)
# Která planeta se otáčí opačně než Země a zároveň nemá prstence?
df %>%
filter(rotation < 0 & rings == FALSE) %>%
select(name)
df
# Která planeta se otáčí opačně než Země a zároveň nemá prstence?
df %>%
filter(rotation < 0 & rings == FALSE) %>%
select(name)
# Vyberte nejmenší planetu
df %>%
select(min(diameter))
# Vyberte nejmenší planetu
df %>%
filter(min(diameter))
# Vyberte nejmenší planetu
df %>%
(min(diameter))
# Vyberte nejmenší planetu
min(df$diameter)
# Vyberte nejmenší planetu
df %>%
filter(diamter = min(df$diameter)) %>%
select(name)
# Vyberte nejmenší planetu
df %>%
filter(diamter == min(df$diameter)) %>%
select(name)
# Vyberte nejmenší planetu
df %>%
filter(diameter == min(df$diameter)) %>%
select(name)
df
# Seřaďte planety podle velikosti (diameter)
df %>%
sort(diameter)
# Seřaďte planety podle velikosti (diameter)
df %>%
order(diameter)
# Seřaďte planety podle velikosti (diameter)
df %>%
order_by(diameter)
# Seřaďte planety podle velikosti (diameter)
df %>%
order_by(diameter)
# Seřaďte planety podle velikosti (diameter)
df %>%
arrange(order_by(diameter))
# Seřaďte planety podle velikosti (diameter)
df[order(diameter)]
df
# Seřaďte planety podle velikosti (diameter)
df[order(df$diameter)]
# Seřaďte planety podle velikosti (diameter)
df %>%
arrange(diameter)
# Seřaďte planety podle velikosti (diameter)
df %>%
arrange(desc(diameter))
# Seřaďte planety podle toho, jestli mají prstence, a až poté podle velikosti
df %>%
group_by(rings)
# Seřaďte planety podle toho, jestli mají prstence, a až poté podle velikosti
df %>%
group_by(rings) %>%
arrange(desc(diameter))
# Seřaďte planety podle toho, jestli mají prstence, a až poté podle velikosti
df %>%
group_by(rings) %>%
arrange(desc(diameter), rings)
# Seřaďte planety podle toho, jestli mají prstence, a až poté podle velikosti
df %>%
group_by(rings) %>%
arrange(rings, desc(diameter))
# Seřaďte planety podle toho, jestli mají prstence, a až poté podle velikosti
df %>%
arrange(rings, desc(diameter))
# Kolik je planet, které se otáčejí opačně než Země (záporná rotace)?
df %>%
filter(rotation < 0)
# Kolik je planet, které se otáčejí opačně než Země (záporná rotace)?
df %>%
filter(rotation < 0) %>%
count()
# Vyberte planetu s nejrychlejší rotací (bez ohledu na směr rotace)
df %>%
filter(rotation = max(df$rotation))
# Vyberte planetu s nejrychlejší rotací (bez ohledu na směr rotace)
df %>%
filter(rotation == max(df$rotation))
# Vyberte planetu s nejrychlejší rotací (bez ohledu na směr rotace)
df %>%
filter(rotation == max(df$rotation)) %>%
select(name)
df
# Vyberte 2 planety s nejrychlejší rotací (opět bez ohledu na směr)
df %>%
arrange(desc(rotation)) %>%
slice_head(n = 2)
