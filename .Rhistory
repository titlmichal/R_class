if_else(x %in% c(997, 998, 999), NA, x)
}
fix_na(c(12, 997, 33, 998,  45, 999))
fix_na(c(12, 997, 33, 998,  45, 999), c(997, 998, 999))
#můžeme si i dospecifikovat argument na dané missing
fix_na <- function(x, missing) {
if_else(x %in% missing, NA, x)
}
fix_na(c(12, 997, 33, 998,  45, 999), c(997, 998, 999))
# Například tato funkce spojít všechny prvky dohromady definovaným
# oddělovačem
commas <- function(x) {
str_flatten(x, collapse = ", ", last = " and ")
}
commas(c("cat", "dog", "pigeon"))
# Tato funkce by vypočetla variační koeficient
#poměr mezi SD a průměrem
var_coef <- function(x, na.rm = FALSE) {
sd(x, na.rm = na.rm) / mean(x, na.rm = na.rm)
}
var_coef(runif(100, min = 0, max = 50))
var_coef(runif(100, min = 0, max = 500))
var_coef(runif(100, min = 0, max = 50))
var_coef(runif(100, min = 0, max = 500))
# Tato funkce by vypočetla počet chybějících hodnot
n_missing <- function(x) {
sum(is.na(x))
}
n_missing(c(NA, NA, NA, 1:7))
n_missin_ratio <- function(x) {
mean(is.na(x))
}
n_missin_ratio(c(NA, NA, NA, 1:7))
df %>%
summarise(n_missing(a))
diamonds
# Když chceme používat funkce balíčku dplyr pro psaní vlastních funkcí
# není to tak jednoduché, jak se na první pohled zdá
grouped_mean <- function(df, group_var, mean_var) {
df %>%
group_by(group_var) %>%
summarize(mean(mean_var))
}
diamonds
# Tento kód háže chybu
diamonds %>%
grouped_mean(cut, carat)
# Protože do dplyr chápe doslovně jako
diamonds %>%
group_by(group_var) %>%
summarize(mean(mean_var))
# Místo toho, aby dosadil hodnoty vstupních argumentů
diamonds %>%
group_by(cut) %>%
summarize(mean(carat))
# Aby dplyr pochopil, co po něm chceme, musíme použít tzv. embracing {{  }}
# Tím mu řekneme, že např. group_var nemá chápat doslova jako jméno proměnné
# z dataframu, ale má místo toho použít hodnotu vstupního argumentu group_var
#takže {{group_var}} bude už chápat, jako vstupní argument, ne název proměnné
grouped_mean <- function(df, group_var, mean_var) {
df %>%
group_by({{ group_var }}) %>%
summarize(mean({{ mean_var }}))
}
# Teď už funkce pracuje tak, jak má
diamonds %>%
grouped_mean(cut, carat)
{
data %>% summarize(
min = min({{ var }}, na.rm = TRUE),
mean = mean({{ var }}, na.rm = TRUE),
median = median({{ var }}, na.rm = TRUE),
max = max({{ var }}, na.rm = TRUE),
n = n(),
n_miss = sum(is.na({{ var }})),
.groups = "drop"
)
}
# Funkce pro výpočet deskriptivních statistik stanovené proměnné
summary6 <- function(data, var) {
data %>% summarize(
min = min({{ var }}, na.rm = TRUE),
mean = mean({{ var }}, na.rm = TRUE),
median = median({{ var }}, na.rm = TRUE),
max = max({{ var }}, na.rm = TRUE),
n = n(),
n_miss = sum(is.na({{ var }})),
.groups = "drop"
)
}
diamonds %>%
summary6(carat)
diamonds %>%
group_by(cut) %>%
summary6(carat)
# Někdy chceme vybrat více proměnných v rámci funkce, která používá
# data-masking, jako je např group_by()
count_missing <- function(df, group_vars, x_var) {
df %>%
group_by({{ group_vars }}) %>%
summarize(
n_miss = sum(is.na({{ x_var }})),
.groups = "drop"
)
}
nycflights13::flights %>%
count_missing(group_vars = c(year, month, day),
x_var = dep_time)
# Někdy chceme vybrat více proměnných v rámci funkce, která používá
# data-masking, jako je např group_by()
count_missing <- function(df, group_vars, x_var) {
df %>%
group_by({{ group_vars }}) %>%
summarize(
n_miss = sum(is.na({{ x_var }})),
.groups = "drop"
)
}
count_missing <- function(df, group_vars, x_var) {
df %>%
group_by(pick({{ group_vars }})) %>%
summarize(
n_miss = sum(is.na({{ x_var }})),
.groups = "drop"
)
}
nycflights13::flights %>%
count_missing(group_vars = c(year, month, day),
x_var = dep_time)
# Ukázka pokročilejší funkce
count_wide <- function(data, rows, cols) {
data %>%
count(pick(c({{ rows }}, {{ cols }}))) %>%
pivot_wider(
names_from = {{ cols }},
values_from = n,
names_sort = TRUE,
values_fill = 0
)
}
diamonds %>%
count_wide(rows = c(clarity, color),
cols = cut)
diamonds %>%
count_wide(rows = c(clarity, color),
cols = cut)
# Po krocích to, co funkce výše dělá
diamonds %>%
count(pick(clarity, color, cut))
diamonds %>%
count(pick(clarity, color, cut)) %>%
pivot_wider(
names_from = cut,
values_from = n,
names_sort = TRUE,
values_fill = 0
)
diamonds %>%
ggplot(aes(x = carat)) +
geom_histogram(binwidth = 0.1)
diamonds %>%
ggplot(aes(x = carat)) +
geom_histogram(binwidth = 0.05)
histogram <- function(df, var, binwidth = NULL) {
df %>%
ggplot(aes(x = {{ var }})) +
geom_histogram(binwidth = binwidth)
}  #binwidth je tedy defaultně nespecifikovaný
diamonds %>%
histogram(carat, binwidth = 0.1)
# Protože funkce histogram vrací ggplot graf, můžeme libovolně přidávat další
# komponenty, např. popisky os
diamonds %>%
histogram(carat, 0.1) ++
labs(x = "Size (in carats)", y = "Number of diamonds")
# Protože funkce histogram vrací ggplot graf, můžeme libovolně přidávat další
# komponenty, např. popisky os
diamonds %>%
histogram(carat, 0.1) +
labs(x = "Size (in carats)", y = "Number of diamonds")
# Protože funkce histogram vrací ggplot graf, můžeme libovolně přidávat další
# komponenty, např. popisky os
diamonds %>%
histogram(carat, 0.1) +
labs(x = "Size (in carats)", y = "Number of diamonds")
linearity_check <- function(df, x, y) {
df %>%
ggplot(aes(x = {{ x }}, y = {{ y }})) +
geom_point() +
geom_smooth(method = "loess", formula = y ~ x, color = "red",
fill = "red", alpha = .2) +
geom_smooth(method = "lm", formula = y ~ x, color = "blue", se = FALSE)
}
starwars %>%
filter(mass < 1000) %>%
linearity_check(mass, height)
starwars
starwars %>%
colnames()
# Zde např. funkce fct_infreq() pro seřazení úrovní faktoru podle zastoupení a
# fct_rev pro reverzi jejich pořadí, aby početnější úrovně byly v grafu
# od shora
sorted_bars <- function(df, var) {
df %>%
mutate({{ var }} := fct_rev(fct_infreq({{ var }})))  %>%
ggplot(aes(y = {{ var }})) +
geom_bar()
}
# Vraťme se ještě k funkci histogram()
histogram <- function(df, var, binwidth = NULL) {
df %>%
ggplot(aes(x = {{ var }})) +
geom_histogram(binwidth = binwidth)
}
diamonds %>%
sorted_bars(clarity)
histogram(diamonds, var = carat, binwidth = 0.1)
# Bylo by pěkné, aby generavala graf i s vhodným nadpisem, např.
# Histogram proměnné carat s šířkou sloupce = 0.1
# Ale carat jako vstupní argument není textový vektor obklopený ""
# Takže by to NEšlo jednoduše s pomocí
str_c("Histogram proměnné", carat, "s šířkou sloupce =", 0.1)
histogram <- function(df, var, binwidth) {
label <- rlang::englue("A histogram of {{var}} with binwidth {binwidth}")
df %>%
ggplot(aes(x = {{ var }})) +
geom_histogram(binwidth = binwidth) +
labs(title = label)
}
histogram(diamonds, var = carat, binwidth = 0.1)
rescale_01(1:100, 1, 10)
rescale_01(1:100, min = 1, max = 10)
rescale_01 <- function(x, min = 0, max = 1) {
rng <- range(min:max, finite = TRUE) # Ignorovat nekonečné hodnoty
output <- (x - rng[1]) / (rng[2] - rng[1])
new_range <- max - min
output <- output*new_range + min
return(output)
}
rescale_01(1:100, min = 1, max = 10)
rescale_01 <- function(x, min = 0, max = 1) {
rng <- range(x, finite = TRUE) # Ignorovat nekonečné hodnoty
output <- (x - rng[1]) / (rng[2] - rng[1])
new_range <- max - min
output <- output*new_range + min
return(output)
}
# Ukažte pak cvičné použití nové funkce např. na vektoru
1:100
rescale_01(1:100, min = 1, max = 10)
rescale_01(1:100, min = 5, max = 15)
#z cvičení z hodiny:
#když převracím proměnné, tak odečítám hodnotu od x, které je vlastně
#součet nejvyšší a nejnižší hodnoty
reverse <- function(x) {
y <- sum(range(x))
y - x
}
revers(2:6)
reverse(2:6)
# Ukažte cvičně použití této funkce např. na datasetu diamonds
diamonds
?diamonds
# Použijte tento dataset
df <- haven::read_sav("https://is.muni.cz/go/ol7a9l") %>%
select(gender, age, PSS1:PSS10)
df
library(lavaan)
library(tidyverse)
# Jména položek
items <- str_c("PSS",
str_pad(1:10, pad = 0, width = 2))
items
# Jména položek
items <- str_c("PSS",
str_pad(1:10, pad = 0, width = 1))
items
# Převrácení reverzních
reversed <- items[4, 5, 7, 8]
items %>%
select(4,5,7,8)
items %>%
select(PSS4, PSS5)
# Převrácení reverzních
reversed <- items[c(4, 5, 7, 8)]
df
df %>%
describe()
df %>%
summary()
df <- df %>%
mutate(
across(
all_of(reversed),
~4 - .x
)
)
# Pro output modelu
output <- function(fit) {
summary(fit, std = TRUE, ci = TRUE, fit = TRUE)
}
# Pro indexy shody s daty
fit_measures <- function(fit) {
out <- fitMeasures(
fit,
fit.measures = c("chisq", "chisq.scaled", "df", "cfi", "cfi.robust",
"rmsea", "rmsea.ci.lower", "rmsea.ci.upper",
"rmsea.robust", "rmsea.ci.lower.robust",
"rmsea.ci.upper.robust",
"srmr")) %>%
as.list()
out$AIC <- AIC(fit)
out$BIC <- BIC(fit)
out
}
df %>%
summary()
m_1 <- "
DCQ =~ PSS1 + PSS2 + PSS3 + PSS4 + PSS5 + PSS6 + PSS7 + PSS8 + PSS9 + PSS10
"
fit_1 <- my_cfa(df, m_1)
# Pro odhad CFA
my_cfa <- function(data, model, ...) {
lavaan::cfa(data = data,
model = model,
estimator = "ml",
missing = "listwise", #nejsou chybějící - stačí listwise
...)
}
m_1 <- "
DCQ =~ PSS1 + PSS2 + PSS3 + PSS4 + PSS5 + PSS6 + PSS7 + PSS8 + PSS9 + PSS10
"
fit_1 <- my_cfa(df, m_1)
output(fit_1)
m_1 <- "
PSS =~ PSS1 + PSS2 + PSS3 + PSS4 + PSS5 + PSS6 + PSS7 + PSS8 + PSS9 + PSS10
"
fit_1 <- my_cfa(df, m_1)
output(fit_1)
m_2 <- "
PSS_poz =~ PSS4 + PSS5 + PSS7 + PSS8
PSS_neg =~ PSS1 + PSS2 + PSS3 + PSS6 + PSS9 + PSS10
"
fit_2 <- my_cfa(df, m_2)
output(fit_2)
m_list <- list(
one = m_1,
three = m_2)
# Porovnejte oba modely z hlediska shody s daty
data.frame(
Measure = names(fit_1_measures),
Model_1 = unlist(fit_1_measures),
Model_2 = unlist(fit_2_measures)
)
fit_1_measures <- fit_measures(fit_1)
m_2 <- "
PSS_poz =~ PSS4 + PSS5 + PSS7 + PSS8
PSS_neg =~ PSS1 + PSS2 + PSS3 + PSS6 + PSS9 + PSS10
"
fit_2 <- my_cfa(df, m_2)
output(fit_2)
fit_2_measures <- fit_measures(fit_2)
# Porovnejte oba modely z hlediska shody s daty
data.frame(
Measure = names(fit_1_measures),
Model_1 = unlist(fit_1_measures),
Model_2 = unlist(fit_2_measures)
)
# Porovnejte oba modely z hlediska shody s daty
data.frame(
#  Measure = names(fit_1_measures),
Model_1 = unlist(fit_1_measures),
Model_2 = unlist(fit_2_measures)
)
# Porovnejte oba modely z hlediska shody s daty
data.frame(
#  Measure = names(fit_1_measures),
Model_1 = round(unlist(fit_1_measures), 2),
Model_2 = unlist(fit_2_measures)
)
# Porovnejte oba modely z hlediska shody s daty
data.frame(
#  Measure = names(fit_1_measures),
Model_1 = round(unlist(fit_1_measures), 4),
Model_2 = round(unlist(fit_2_measures), 4)
)
# Porovnejte oba modely z hlediska shody s daty
data.frame(
Model_1 = round(unlist(fit_1_measures), 4),
Model_2 = round(unlist(fit_2_measures), 4)
)
# Ukažte cvičně použití této funkce např. na datasetu diamonds
diamonds
library(tidyverse)
rescale_01 <- function(x, min = 0, max = 1) {
#lze tady ještě dopsat stopifnot ... a podmínky pro max > min, x v rozmezí apod.
rng <- range(x, finite = TRUE) # Ignorovat nekonečné hodnoty
output <- (x - rng[1]) / (rng[2] - rng[1])
new_range <- max - min
output <- output*new_range + min
return(output)
}
# Ukažte pak cvičné použití nové funkce např. na vektoru
1:100
rescale_01(1:100, min = 5, max = 15)
reverse(2:6)
rescale_01 <- function(x, min = 0, max = 1) {
#lze tady ještě dopsat stopifnot ... a podmínky pro max > min, x v rozmezí apod.
rng <- range(x, finite = TRUE) # Ignorovat nekonečné hodnoty
output <- (x - rng[1]) / (rng[2] - rng[1])
new_range <- max - min
output <- output*new_range + min
return(output)
}
# Ukažte pak cvičné použití nové funkce např. na vektoru
1:100
rescale_01(1:100, min = 5, max = 15)
#z cvičení z hodiny:
#když převracím proměnné, tak odečítám hodnotu od x, které je vlastně
#součet nejvyšší a nejnižší hodnoty
reverse <- function(x) {
y <- sum(range(x))
y - x
#POZOR, předpokládá přítomnost krajních hodnot v datech
}
reverse(2:6)
# 3) ---------------------------------------------------
# Takto bychom
diamonds %>%
count(pick(cut, color)) %>%
mutate(p = n / sum(n),
.by = cut)
summary_mdn <- function(data, group_vars, x_var) {
data %>%
group_by(pick(c({{ group_vars }}))) %>%
summarise(
median = median({{x_var}}, na.rm = TRUE),
mad = mad({{x_var}}, na.rm = TRUE)
)
}
# Ukažte cvičně použití této funkce např. na datasetu diamonds
diamonds
?diamonds
summary_mdn(diamonds, diamonds$cut, diamonds$carat)
summary_mdn <- function(data, group_vars, x_var) {
data %>%
group_by(across(all_of(group_vars))) %>%
summarise(
median = median({{x_var}}, na.rm = TRUE),
mad = mad({{x_var}}, na.rm = TRUE)
)
}
# Ukažte cvičně použití této funkce např. na datasetu diamonds
diamonds
?diamonds
summary_mdn(diamonds, diamonds$cut, diamonds$carat)
summary_mdn(diamonds, cut, carat)
summary_mdn(diamonds, group_vars = c("cut", "color"), x_var = carat)
summary_mdn(diamonds, "cut", x_var = carat)
summary_mdn(diamonds, "cut", carat)
summary_mdn(diamonds, cut, carat)
summary_mdn(diamonds, "cut", carat)
# Ukažte cvičně použití této funkce např. na datasetu diamonds
diamonds
summary_mdn(diamonds, c("cut", "color"), carat)
# Ukažte cvičně použití této funkce např. na datasetu diamonds
diamonds
# Takto bychom vytvořili funkci, která vezme dataframe, vypočte
# četnosti jednotlivých kategorií proměnných var1 a var2
# a nakonec vypočte relativní četnosti proměnné var2 v rámci každé
# kategorie var1
count_prop <- function(data, var1, var2) {
data %>%
count(pick(c({{ var1 }},  {{ var2 }}))) %>%
mutate(p = n / sum(n),
.by = {{ var1 }})
}
count_prop(diamonds, cut, color)
count_prop(diamonds, cut, color) %>%
ggplot(aes(x = cut, y = n)) %>%
geom_bar()
count_prop(diamonds, cut, color) %>%
ggplot(aes(x = cut, y = n)) +
geom_bar()
count_prop(diamonds, cut, color) %>%
ggplot(aes(x = cut, y = n)) +
geom_line()
count_prop(diamonds, cut, color)
count_prop(diamonds, cut, color) %>%
ggplot(aes(x = cut, y = n, fill = color)) +
geom_bar()
count_prop(diamonds, cut, color) %>%
ggplot(aes(x = cut, y = n, fill = color)) +
geom_bar(stat = "identity", position = "stack")
plot_bar <- function(data, var1, var2) {
data %>%
count(pick(c({{ var1 }}, {{ var2 }}))) %>%
mutate(p = n/sum(n),
.by = {{ var1}}) %>%
ggplot(aes(x = {{ var1 }}, y = p, fill = {{ var2 }})) +
geom_bar(stat = "identity", position = "stack")
}
plot_bar(diamonds, cut, color)
plot_bar <- function(data, var1, var2) {
data %>%
count(pick(c({{ var1 }}, {{ var2 }}))) %>%
mutate(p = n/sum(n),
.by = {{ var1}}) %>%
ggplot(aes(x = {{ var1 }}, y = n, fill = {{ var2 }})) +
geom_bar(stat = "identity", position = "stack")
}
plot_bar(diamonds, cut, color)
